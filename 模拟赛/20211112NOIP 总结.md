# 20211112NOIP 总结

### 触手 xyx

读完题之后忘记要让步数最少了，觉得是到水题，只要分治即可，后来看了一下样例，发现还有步数，于是换成了单调栈做法。

让$b_i$表示位置$i$向后延伸$x$个单位的最小高度，那么在面积不变的情况下，删除一些没有用的起始点就能让步数尽量小。

发现如果有$i<j<k$的三个位置$i,j,k$，当$i$和$k$油漆的部分可以完全覆盖$j$的部分，那么$j$就可以删去，这样就做完了。

考场上计算$b_i$用了ST表，假如换成单调队列就是$O(n)$的了。

### 数数 count

仔细分析一下的操作，发现能够通过这个操作让$a_i$和前面任意个$a_j(j<i)$异或得到新的$i$，这样每一个位置就是独立的，只需要统计每个位置的情况，最后相乘就是答案了。

这个问题就是一个经典的线性基求解的问题，套板子即可。

### 偷袭 wude

这题有两个思路，分别为两种分层图：

1. 设$f_{i,j}$表示概率为$i$，走到$j$的最小步数
2. 设$g_{i,j}$表示走到$i$用了$j$的最大概率

跑了一下暴力，发现第一种分层图$i$的取值有16000种，很明显会时超，然后就弃掉了。

第二个种分层图当边的概率都不是1的时候$j$最大为28，即$\log_{0.99}{0.75}$，这样就能够90分了，但是考场的时候忘记把这个优化加上只拿了50。

考虑优化第一种分层图。

这道题有一个很有意思的压缩状态技巧，即**两个状态在所有转移方案中转移到的新状态都是一样的，那么这两个状态可以视为相等状态**，这样就可以把16000个状态压缩成500个，然后同层用bfs更新，省略常数就是$O(500n)$

### 转化 trans

考场上想到了如何排序以外的部分。

发现取一个区间操作两次不会产生任何影响，即操作是可逆的，这启发我们找一个中间状态使得总共用$O(m)$使得$a,b$都变成这个状态，很容易想到排序成升序或降序。

这里从升序入手，考虑一下常用的排序，有快排和归并排序。稍微想想快排被否掉了，所以想怎么归并。

发现归并的难点在于如何合并两段分别都是上升的序列，发现直接做没有什么前途，于是考虑分治。

下面是完成区间$[l,r]$合并任务的过程：

1. 取整段数的中位数$M$，让目前的左区间$[l,mid]$和右区间$[mid+1,r]$按$M$分成前后两端，从前往后分别记为$A,B,C,D$
2. 让$B,C$分别反转，然后让$BC$整体反转，此时区间分成两部分，其中左边都小于等于$M$，右边都大于$M$那么只要让这两部分都成为升序即可
3. 可以发现正两部分都由上升的两部分组成，这就是同样的子问题，分治处理即可

下面是复杂度：

令$T(n)$表示长度为$n$的区间归并中合并两个上升区间的次数，有如下递推式：
$$
\begin{aligned}
T(n) & =O(n)+2T(\frac{n}{2}) \space (n>1)\\
T(1) & =1
\end{aligned}
$$
我们猜测$T(n)=n\log n$，带入可以发现是对的。

于是总复杂度就是$O(n(\log n)^2)$。

![trans](https://github.com/jiangruizhang/Summary/blob/main/20211112trans.png)

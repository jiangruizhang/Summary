# Solution

### DP

1. 性质一：对数组进行差分，在数轴上画一画很快可以发现对$i$进行依次操作，就是让差分数组中$i$左右两边的值交换
2. 性质二：观察一下最终答案的差分数组，可以发现是一个构成一个谷。
3. 对于一组数据的答案是$n\sum_{i=1}^{n}a_i^2-(\sum_{i=1}^{n}a_i)^2$
4. 数据中的每个元素都加上同一个数方差不变，这个就是方差的意义了：衡量数据的波动情况

所以，我们可以自由调整$b$的顺序，然后钦定$a_1=0$，然后构造$a$。

根据以上，我们不难想到可以将差分数组$b$排序，然后从小到大就行决策，放在目前已经构造的新的差分数组$c$的左侧或右侧；在DP的状态中记录上述式子的一部分，然后DP的值就是另一部分的最优解。

所以我们设$f_{i,j}$表示已经生成了$i$个$a$（即使用了$i-1$个差分值），目前$a$的和（后半部分）为$j$，可以求得的最小的平方的和（前半部分）。

那么考虑从$i$转移到$i+1$，即决策第$i$个差分值，分为两种：

1. 放在现在的$a$的后面，那么新的$a_{i+1}$就是目前所有$b$的和（与$j$无关），那么转移就是$f_{i+1,j+a_{i+1}}=f_{i,j}+a_{i+1}^2$。
2. 放在现在的$a$的前面，就是让目前所有的$a$都加上$b_i$，然后在前面插入一个$0$，稍微推一下就行了，那么转移就是$f_{i+1,j+ib_{i}}=f_{i,j}+ib_i^2+2jb_i$。

![pushback](D:\JiangRuizhang\20211120NOIP\variance\pushback.png)

![pushfront](D:\JiangRuizhang\20211120NOIP\variance\pushfront.png)

那么最终的答案就是$\min\{ nf_{n,j}-j^2\}$。

算一下复杂度，大概粗估上界是$O(n^2a_n)$的，并不能通过，但是精细实现一下还是能通过的，当然也有严谨的做法能够保证通过，如下。

### 搜索

可以发现DP是无法通过最后一档分。

基于以上思路，我们对于$b$的分配使用搜索，即对于相等的差分值，如何左右分配，当然对于差分值为0是不用搜索的，随便放就好了。

这样，为了能够卡时间，最劣情况就是要搜索的每种差分值都是连续的，且都只出现1次，那么最劣复杂度就是$O(2^{\sqrt n})$了。


# 20211116NOIP 总结

### 数析送命题 function

假如能够找到形如$f(x_0)=f(x_0+T)=f(x_0+2T)=\dots$的等式，并且使得$T$最小，那么就找到了答案。

观察一个偶函数性质会对$x_0$产生什么作用，计算可知$f(x+A)$是偶函数说明$f(x_0)=f(2A-x_0)$。同理，算一下给出的奇函数性质，如果$f(x+B)$是奇函数，那么$f(x_0)=-f(2B-x_0)$。

发现只用一个对$x_0$作用是没什么用的，因为$x_0$的系数是$-1$不符合我们的要求，所以要让两个奇偶性质同时作用，最终效果就是$|f(x_0)|=|f(2(k_1-k_2)+x_0)|$。这里带有绝对值是因为使用一个偶函数和一个奇函数会让函数值取反，这启发我们当使用一奇一偶的时候一共作用四次。

之后就是$gcd$的活了。

### 摸鱼看比赛 match

考试的时候写了个暴力，没有分析出性质。

其实$\frac{p}{q}$与$\frac{1}{2}$的大小关系没什么关系，因为这个只是决定编号小强还是编号大强，如果是编号小强，反过来就行了，而且答案是对称的。

考虑一下对于$i$的最优抽签，那么一定是$i$在第一位，$i$后面先全部放比$i$弱的，然后放比$i$强的，至此最大概率变成了概率。

那么这里重新定义$p,q$，令$p,q$分别表示较大的和较小的概率，并且钦定编号大的强。

设$f_{i,j}$表示在$2^i$个队伍的局面中，队伍$j$获胜的概率，$g_{i,j}$表示在$2^i$个队伍的局面中，小于等于$j$的队伍获胜的概率。

![20211116match](https://github.com/jiangruizhang/Summary/blob/main/20211116match.png)

先计算$f$，考虑对$j$分类讨论，当$j\le 2^{i-1}$时，下面的部分$j$胜出概率为$f_{i-1,j}$，与上面的PK，获胜概率为$q$，所以$f_{i,j}=qf_{i-1,j}$；当$j>2^{i-1}$时，下面一定是$j$较强，所以是$p^{i-1}$，当与上面PK时，有$g_{i-1,j-2^{i-1}}$的概率和较小的PK，有$1-g_{i-1,j-2^{i-1}}$的概率和较大的PK，所以$f_{i,j}=p^{i-1}[pg_{i-1,j-2^{i-1}}+q(1-g_{i-1,j-2^{i-1}})]$。

在计算$g$，依然是对$j$分类讨论，当$j \le 2^{i-1}$时，和上面PK获胜概率为$q$，$g_{i,j}=qg_{i-1,j}$；当$j > 2^{i-1}$时，和较小的PK一定还是$j$，故这部分概率为$1$，和较大的PK，概率为$q$，所以$g_{i,j}=g_{i-1,j-2^{i-1}}+q(1-g_{i-1,j-2^{i-1}})$。

发现转移和$j$其实没有什么关系，所以令$F_i,G_i$为$f_i,g_i$的和，那么有如下式子：
$$
\begin{aligned}
F_i & =qF_{i-1}+p^{i-1}(pG_{i-1}+2^{i-1}q-qG_{i-1})\\
 & =qF_{i-1}+q2^{i-1}p^{i-1}+(2p-1)p^{i-1}g_{i-1}\\
G_i & = qG{i-1}+G{i-1}+q2^{i-1}-qG_{i-1}\\
 & = G_{i-1}+q2^{i-1}
\end{aligned}
$$
上面有用到$p+q=1$。

发现这个可以对$F_i,2^ip^i,p^iG_i$进行矩阵乘法。

设$a_i=F_i,b_i=2^ip^i,c_i=p^iG_i$，考虑递推$a,b,c$，如下：
$$
\begin{aligned}
a_i & = qa_{i-1}+qb_{i-1}+(2p-1)c_{i-1}\\
b_i & = 2pb_{i-1}\\
c_i & = pc_{i-1}+pqb_{i-1}
\end{aligned}
$$
根据这个套用矩阵乘法即可，如下：
$$
\left[ \begin{matrix}
a_{i-1} & b_{i-1} & c_{i-1}
\end{matrix} \right]
\left[\begin{matrix}
q & 0 & 0\\
q & 2p & pq \\
2p-1 & 0 & p\\
\end{matrix}\right]
=
\left[ \begin{matrix}
a_{i} & b_{i} & c_{i}
\end{matrix} \right]
$$

### 发呆数星星 star

根据一些数学知识可以证明，一个数的拆分方案为其模四为一的质因子的指数加一的积，用通式表达就是：若$n=\prod_{i=1}^{k}p_i^{q_i}$，令$S=\{i|p_i\equiv1\mod 4\}$，那么拆分方案为$\prod_{i\in S}(q_i+1)$。

于是就可以参考约数国王的做法，这里写一下一种更高效的约数国王做法。

可以发现反素数一定是某个反素数的倍数，即有另一个反素数拓展而来，所以用一个堆来维护目前反素数的最小拓展值即可。

### 秋名山车神 game

这道题证明了队列的长度不会超过$\sqrt n$，从而想出复杂度正确的做法。

操作可以分成两种，一种是加入一个点，一种是查询包含$x$的三元组。

加入一个点可以扫一遍队列，维护连边情况的bitset。

查询包含$x$的三元组，也可以扫一遍队列，找两者两边的交中是否有可以选的点。

关于边的解封，可以看作修改两个点的bitset，然后把分别查询三元组。

~~未实现~~

